#!/bin/bash

# SnapSync v2.5 增强版系统恢复工具
# 完全适配v2.5增强版备份脚本的所有特性

# 权限检查
if [ "$EUID" -ne 0 ]; then
    echo -e "\033[0;31m错误: 请使用root权限运行此脚本\033[0m"
    exit 1
fi

# 颜色设置
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'
BLUE='\033[0;34m'; CYAN='\033[0;36m'; NC='\033[0m'

# 路径定义 (与备份脚本完全一致)
CONFIG_FILE="/etc/system_snapshot/config.conf"
LOG_DIR="/var/log/system_snapshot"
RESTORE_LOG_FILE="$LOG_DIR/restore.log"

# 日志函数
log() {
    mkdir -p "$LOG_DIR"
    echo -e "$(date '+%F %T') $1" | tee -a "$RESTORE_LOG_FILE"
}

# 加载配置文件
log "${CYAN}正在加载备份工具配置文件...${NC}"
if [ -f "$CONFIG_FILE" ]; then
    source "$CONFIG_FILE"
    log "${GREEN}✓ 配置文件加载成功！${NC}"
    # 构建完整远程路径
    FULL_REMOTE_PATH="$TARGET_BASE_DIR/$REMOTE_DIR_NAME"
else
    log "${YELLOW}警告: 未找到备份配置文件，请先运行备份脚本进行初始化${NC}"
    BACKUP_DIR="/backups"
fi

# 标题
clear
echo -e "${BLUE}================================================${NC}"
echo -e "${BLUE}        系统快照恢复工具 v2.5+ (增强版)          ${NC}"
echo -e "${BLUE}================================================${NC}"
echo ""

# 选择恢复方式
echo -e "${CYAN}请选择恢复方式:${NC}"
echo -e "1) ${GREEN}本地恢复${NC} - 从本地备份目录恢复"
echo -e "2) ${GREEN}远程恢复${NC} - 从远程服务器下载并恢复"
echo ""
read -p "请选择 [1-2]: " RESTORE_TYPE

if ! [[ "$RESTORE_TYPE" =~ ^[1-2]$ ]]; then
    log "${RED}错误: 无效选择${NC}"
    exit 1
fi

# 本地恢复
local_restore() {
    echo -e "\n${BLUE}=== 本地恢复模式 ===${NC}"
    
    if [ ! -d "$BACKUP_DIR" ]; then
        log "${RED}错误: 备份目录不存在 - $BACKUP_DIR${NC}"
        exit 1
    fi

    # 查找快照文件 - 支持多种格式
    SNAPSHOT_FILES=()
    for pattern in "*.tar.gz" "*.tgz" "*.tar.bz2" "*.tar.xz" "*.tar"; do
        while IFS= read -r -d '' file; do
            SNAPSHOT_FILES+=("$file")
        done < <(find "$BACKUP_DIR" -name "system_snapshot_$pattern" -print0 2>/dev/null)
    done
    
    if [ ${#SNAPSHOT_FILES[@]} -eq 0 ]; then
        log "${RED}错误: 未找到快照文件${NC}"
        exit 1
    fi

    # 按时间排序
    IFS=$'\n' SNAPSHOT_FILES=($(printf '%s\n' "${SNAPSHOT_FILES[@]}" | sort -r))

    # 显示可用快照
    echo -e "${YELLOW}可用快照:${NC}"
    for i in "${!SNAPSHOT_FILES[@]}"; do
        SNAPSHOT_NAME=$(basename "${SNAPSHOT_FILES[$i]}")
        SNAPSHOT_SIZE=$(du -h "${SNAPSHOT_FILES[$i]}" | cut -f1)
        SNAPSHOT_DATE=$(date -r "${SNAPSHOT_FILES[$i]}" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "未知")
        echo -e "$((i+1))) ${GREEN}$SNAPSHOT_NAME${NC} ($SNAPSHOT_SIZE, $SNAPSHOT_DATE)"
    done

    read -p "选择快照编号 [1-${#SNAPSHOT_FILES[@]}]: " CHOICE
    
    if ! [[ "$CHOICE" =~ ^[0-9]+$ ]] || [ "$CHOICE" -lt 1 ] || [ "$CHOICE" -gt ${#SNAPSHOT_FILES[@]} ]; then
        log "${RED}错误: 无效选择${NC}"
        exit 1
    fi

    LOCAL_SNAPSHOT="${SNAPSHOT_FILES[$((CHOICE-1))]}"
    SNAPSHOT_NAME=$(basename "$LOCAL_SNAPSHOT")
    
    log "${YELLOW}选择的快照: $SNAPSHOT_NAME${NC}"
}

# 远程恢复
remote_restore() {
    echo -e "\n${BLUE}=== 远程恢复模式 ===${NC}"
    
    # 检查SSH工具
    if ! command -v ssh &> /dev/null || ! command -v scp &> /dev/null; then
        log "${RED}错误: 缺少SSH工具${NC}"
        exit 1
    fi

    # 使用配置文件中的连接信息
    if [ -n "$TARGET_IP" ]; then
        log "${CYAN}使用配置文件连接信息:${NC}"
        log "服务器: $TARGET_USER@$TARGET_IP:$SSH_PORT"
        log "远程路径: $FULL_REMOTE_PATH"
    else
        log "${RED}错误: 配置文件中缺少远程服务器信息${NC}"
        exit 1
    fi

    # SSH连接测试 (优先使用密钥)
    if [ -f "/root/.ssh/id_ed25519" ]; then
        SSH_CMD="ssh -i /root/.ssh/id_ed25519 -p $SSH_PORT -o StrictHostKeyChecking=no $TARGET_USER@$TARGET_IP"
        SCP_CMD="scp -i /root/.ssh/id_ed25519 -P $SSH_PORT -o StrictHostKeyChecking=no"
    else
        read -s -p "SSH密码: " SSH_PASS
        echo ""
        if ! command -v sshpass &> /dev/null; then
            # 尝试安装sshpass
            if command -v apt-get &> /dev/null; then
                apt-get update && apt-get install -y sshpass
            elif command -v yum &> /dev/null; then
                yum install -y sshpass
            else
                log "${RED}错误: 无法安装sshpass，请手动安装${NC}"
                exit 1
            fi
        fi
        SSH_CMD="sshpass -p '$SSH_PASS' ssh -p $SSH_PORT -o StrictHostKeyChecking=no $TARGET_USER@$TARGET_IP"
        SCP_CMD="sshpass -p '$SSH_PASS' scp -P $SSH_PORT -o StrictHostKeyChecking=no"
    fi

    # 测试连接
    if ! eval "$SSH_CMD 'echo 连接测试'" &>/dev/null; then
        log "${RED}错误: 无法连接远程服务器${NC}"
        exit 1
    fi
    log "${GREEN}✓ 远程连接成功${NC}"

    # 获取远程快照列表
    SNAPSHOT_LIST=$(eval "$SSH_CMD 'find $FULL_REMOTE_PATH/system_snapshots -name \"*.tar*\" -type f | sort -r'" 2>/dev/null)
    
    if [ -z "$SNAPSHOT_LIST" ]; then
        log "${RED}错误: 远程未找到快照文件${NC}"
        exit 1
    fi

    # 显示远程快照
    echo -e "${YELLOW}远程可用快照:${NC}"
    IFS=$'\n' SNAPSHOT_FILES=($SNAPSHOT_LIST)
    
    for i in "${!SNAPSHOT_FILES[@]}"; do
        SNAPSHOT_NAME=$(basename "${SNAPSHOT_FILES[$i]}")
        SNAPSHOT_INFO=$(eval "$SSH_CMD 'ls -lh \"${SNAPSHOT_FILES[$i]}\"'" 2>/dev/null)
        if [ -n "$SNAPSHOT_INFO" ]; then
            SNAPSHOT_SIZE=$(echo "$SNAPSHOT_INFO" | awk '{print $5}')
            SNAPSHOT_DATE=$(echo "$SNAPSHOT_INFO" | awk '{print $6" "$7" "$8}')
            echo -e "$((i+1))) ${GREEN}$SNAPSHOT_NAME${NC} ($SNAPSHOT_SIZE, $SNAPSHOT_DATE)"
        else
            echo -e "$((i+1))) ${GREEN}$SNAPSHOT_NAME${NC}"
        fi
    done

    read -p "选择快照编号 [1-${#SNAPSHOT_FILES[@]}]: " CHOICE
    
    if ! [[ "$CHOICE" =~ ^[0-9]+$ ]] || [ "$CHOICE" -lt 1 ] || [ "$CHOICE" -gt ${#SNAPSHOT_FILES[@]} ]; then
        log "${RED}错误: 无效选择${NC}"
        exit 1
    fi

    SELECTED_SNAPSHOT="${SNAPSHOT_FILES[$((CHOICE-1))]}"
    SNAPSHOT_NAME=$(basename "$SELECTED_SNAPSHOT")

    # 下载快照
    LOCAL_TEMP_DIR="/tmp/restore_$$"
    mkdir -p "$LOCAL_TEMP_DIR"
    LOCAL_SNAPSHOT="$LOCAL_TEMP_DIR/$SNAPSHOT_NAME"

    log "${YELLOW}正在下载快照...${NC}"
    if ! eval "$SCP_CMD $TARGET_USER@$TARGET_IP:\"$SELECTED_SNAPSHOT\" \"$LOCAL_SNAPSHOT\""; then
        log "${RED}错误: 下载失败${NC}"
        rm -rf "$LOCAL_TEMP_DIR"
        exit 1
    fi
    log "${GREEN}✓ 下载完成${NC}"
}

# 检测压缩格式并获取解压命令
get_decomp_cmd() {
    local file="$1"
    
    if [[ "$file" =~ \.tar\.gz$ ]] || [[ "$file" =~ \.tgz$ ]]; then
        if command -v pigz &> /dev/null; then
            echo "pigz -dc"
        else
            echo "gunzip -c"
        fi
    elif [[ "$file" =~ \.tar\.bz2$ ]]; then
        echo "bunzip2 -c"
    elif [[ "$file" =~ \.tar\.xz$ ]]; then
        echo "xz -dc"
    elif [[ "$file" =~ \.tar$ ]]; then
        echo "cat"
    else
        echo "cat"  # 默认
    fi
}

# 执行恢复
perform_restore() {
    # 确认操作
    log "\n${RED}警告: 恢复操作不可撤销，将覆盖当前系统状态${NC}"
    read -p "确认继续？[y/N]: " CONFIRM
    if [[ ! "$CONFIRM" =~ ^[Yy]$ ]]; then
        log "${YELLOW}操作已取消${NC}"
        exit 0
    fi

    # 恢复模式选择
    echo -e "\n${YELLOW}恢复模式:${NC}"
    echo "1) 标准恢复 - 保留网络配置"
    echo "2) 完全恢复 - 恢复所有文件"
    read -p "选择模式 [1-2]: " MODE

    if ! [[ "$MODE" =~ ^[1-2]$ ]]; then
        log "${RED}错误: 无效选择${NC}"
        exit 1
    fi

    # 备份关键配置 (标准模式)
    if [ "$MODE" -eq 1 ]; then
        BACKUP_CONFIG_DIR="/tmp/current_config_$$"
        mkdir -p "$BACKUP_CONFIG_DIR"
        cp /etc/fstab "$BACKUP_CONFIG_DIR/" 2>/dev/null
        cp -r /etc/network "$BACKUP_CONFIG_DIR/" 2>/dev/null
        cp -r /etc/netplan "$BACKUP_CONFIG_DIR/" 2>/dev/null
        cp /etc/hostname "$BACKUP_CONFIG_DIR/" 2>/dev/null
        cp /etc/hosts "$BACKUP_CONFIG_DIR/" 2>/dev/null
        cp /etc/resolv.conf "$BACKUP_CONFIG_DIR/" 2>/dev/null
        cp -r /etc/ssh "$BACKUP_CONFIG_DIR/" 2>/dev/null
        cp -r /root/.ssh "$BACKUP_CONFIG_DIR/" 2>/dev/null
    fi

    # 停止服务
    for service in nginx apache2 mysql docker; do
        systemctl stop $service 2>/dev/null || true
    done

    # 获取解压命令
    DECOMP_CMD=$(get_decomp_cmd "$LOCAL_SNAPSHOT")

    # 执行恢复
    log "${BLUE}正在恢复系统...${NC}"
    
    cd /
    if [ "$MODE" -eq 1 ]; then
        # 标准恢复 - 排除网络配置
        eval "$DECOMP_CMD '$LOCAL_SNAPSHOT' | tar -xf - \
            --exclude='dev/*' --exclude='proc/*' --exclude='sys/*' \
            --exclude='run/*' --exclude='tmp/*' \
            --exclude='etc/fstab' --exclude='etc/hostname' --exclude='etc/hosts' \
            --exclude='etc/network/*' --exclude='etc/netplan/*' \
            --exclude='etc/resolv.conf' --exclude='etc/ssh/*' \
            --exclude='root/.ssh/*' --exclude='$BACKUP_DIR/*'"
    else
        # 完全恢复
        eval "$DECOMP_CMD '$LOCAL_SNAPSHOT' | tar -xf - \
            --exclude='dev/*' --exclude='proc/*' --exclude='sys/*' \
            --exclude='run/*' --exclude='tmp/*' --exclude='$BACKUP_DIR/*'"
    fi

    if [ $? -ne 0 ]; then
        log "${RED}错误: 恢复失败${NC}"
        exit 1
    fi

    # 恢复保留的配置 (标准模式)
    if [ "$MODE" -eq 1 ] && [ -d "$BACKUP_CONFIG_DIR" ]; then
        cp "$BACKUP_CONFIG_DIR/fstab" /etc/ 2>/dev/null
        cp -r "$BACKUP_CONFIG_DIR/network" /etc/ 2>/dev/null
        cp -r "$BACKUP_CONFIG_DIR/netplan" /etc/ 2>/dev/null
        cp "$BACKUP_CONFIG_DIR/hostname" /etc/ 2>/dev/null
        cp "$BACKUP_CONFIG_DIR/hosts" /etc/ 2>/dev/null
        cp "$BACKUP_CONFIG_DIR/resolv.conf" /etc/ 2>/dev/null
        cp -r "$BACKUP_CONFIG_DIR/ssh" /etc/ 2>/dev/null
        cp -r "$BACKUP_CONFIG_DIR/.ssh" /root/ 2>/dev/null
        chmod 700 /root/.ssh 2>/dev/null
        chmod 600 /root/.ssh/* 2>/dev/null || true
        rm -rf "$BACKUP_CONFIG_DIR"
    fi

    # 清理临时文件
    if [ "$RESTORE_TYPE" -eq 2 ] && [ -n "$LOCAL_TEMP_DIR" ]; then
        rm -rf "$LOCAL_TEMP_DIR"
    fi

    log "${GREEN}✓ 系统恢复完成！${NC}"
    
    if [ "$MODE" -eq 1 ]; then
        log "${BLUE}已保留当前网络配置${NC}"
    fi

    # 重启提示
    log "\n${YELLOW}建议重启系统以完成恢复${NC}"
    read -p "立即重启？[y/N]: " REBOOT
    if [[ "$REBOOT" =~ ^[Yy]$ ]]; then
        reboot
    fi
}

# 主流程
if [ "$RESTORE_TYPE" -eq 1 ]; then
    local_restore
else
    remote_restore
fi

perform_restore
