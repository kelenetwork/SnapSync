#!/bin/bash

# SnapSync v2.5 增强版系统恢复工具
# 完全适配v2.5增强版备份脚本的所有特性
# 支持ACL、扩展属性、多种压缩格式、完整性验证

# ====================================================================
# 基础检查和初始化
# ====================================================================

# 权限检查
if [ "$EUID" -ne 0 ]; then
    echo -e "\033[0;31m错误: 请使用root权限运行此脚本\033[0m"
    exit 1
fi

# 颜色设置
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[0;33m'
BLUE='\033[0;34m'; CYAN='\033[0;36m'; PURPLE='\033[0;35m'; NC='\033[0m'

# 路径定义 (与备份脚本完全一致)
CONFIG_FILE="/etc/system_snapshot/config.conf"
LOG_DIR="/var/log/system_snapshot"
RESTORE_LOG_FILE="$LOG_DIR/restore.log"
DEBUG_LOG_FILE="$LOG_DIR/restore_debug.log"

# 全局变量
SCRIPT_VERSION="2.5"
RESTORE_TIMESTAMP=$(date +"%Y%m%d%H%M%S")
TEMP_DIR="/tmp/snapsync_restore_$$"
BACKUP_CONFIG_DIR="/tmp/current_config_backup_$$"
LOCK_FILE="/tmp/system_restore.lock"

# 进程锁
exec 200>"$LOCK_FILE"
if ! flock -n 200; then
    echo -e "${RED}错误: 恢复脚本已在运行中${NC}"
    exit 1
fi
echo $$ >&200

# 清理函数
cleanup_on_exit() {
    log_debug "执行清理操作..."
    [ -d "$TEMP_DIR" ] && rm -rf "$TEMP_DIR"
    [ -d "$BACKUP_CONFIG_DIR" ] && rm -rf "$BACKUP_CONFIG_DIR"
    flock -u 200
}
trap 'cleanup_on_exit' EXIT INT TERM

# 日志函数
log() {
    mkdir -p "$LOG_DIR"
    echo -e "$(date '+%F %T') $1" | tee -a "$RESTORE_LOG_FILE"
}

log_debug() {
    mkdir -p "$LOG_DIR"
    echo -e "$(date '+%F %T') [DEBUG] $1" >> "$DEBUG_LOG_FILE"
}

log_error() {
    log "${RED}[ERROR] $1${NC}"
}

log_info() {
    log "${CYAN}[INFO] $1${NC}"
}

log_success() {
    log "${GREEN}[SUCCESS] $1${NC}"
}

log_warning() {
    log "${YELLOW}[WARNING] $1${NC}"
}

# 字节格式化函数
format_bytes() {
    local bytes="\$1"
    if [[ ! "$bytes" =~ ^[0-9]+$ ]]; then
        echo "0B"
        return
    fi
    
    if [ "$bytes" -ge 1073741824 ]; then
        echo "$((bytes / 1073741824)).$(((bytes % 1073741824) * 10 / 1073741824))GB"
    elif [ "$bytes" -ge 1048576 ]; then
        echo "$((bytes / 1048576)).$(((bytes % 1048576) * 10 / 1048576))MB"
    elif [ "$bytes" -ge 1024 ]; then
        echo "$((bytes / 1024)).$(((bytes % 1024) * 10 / 1024))KB"
    else
        echo "${bytes}B"
    fi
}

# Telegram 通知函数
send_telegram() {
    if [ -n "$BOT_TOKEN" ] && [ -n "$CHAT_ID" ]; then
        local rendered=$(printf "%b" "$1")
        curl -sS -m 15 "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
            -d chat_id="$CHAT_ID" --data-urlencode text="$rendered" >/dev/null 2>&1 || true
    fi
}

# ====================================================================
# 系统要求检查
# ====================================================================

check_requirements() {
    log_info "检查系统要求..."
    
    # 基础工具检查
    local required_tools="tar find xargs"
    local missing_tools=""
    
    for cmd in $required_tools; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            missing_tools="$missing_tools $cmd"
        fi
    done
    
    if [ -n "$missing_tools" ]; then
        log_error "缺少必需工具:$missing_tools"
        log_info "正在安装缺失工具..."
        apt-get update >/dev/null 2>&1
        for tool in $missing_tools; do
            apt-get install -y "$tool" >/dev/null 2>&1 || {
                log_error "无法安装 $tool"
                return 1
            }
        done
    fi
    
    # 压缩工具检查
    local compression_support=""
    command -v pigz >/dev/null 2>&1 && compression_support="$compression_support pigz"
    command -v gzip >/dev/null 2>&1 && compression_support="$compression_support gzip"
    command -v gunzip >/dev/null 2>&1 && compression_support="$compression_support gunzip"
    
    if [ -z "$compression_support" ]; then
        log_warning "未找到压缩工具，正在安装..."
        apt-get install -y gzip pigz >/dev/null 2>&1 || true
    fi
    
    # ACL 工具检查
    if ! command -v setfacl >/dev/null 2>&1; then
        log_info "安装 ACL 工具..."
        apt-get install -y acl >/dev/null 2>&1 || log_warning "ACL 工具安装失败"
    fi
    
    # 扩展属性工具检查
    if ! command -v setfattr >/dev/null 2>&1; then
        log_info "安装扩展属性工具..."
        apt-get install -y attr >/dev/null 2>&1 || log_warning "扩展属性工具安装失败"
    fi
    
    log_success "系统要求检查完成"
    return 0
}

# ====================================================================
# 配置加载和初始化
# ====================================================================

load_config() {
    log_info "正在加载备份工具配置文件..."
    
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE" || {
            log_error "配置文件格式错误"
            return 1
        }
        log_success "配置文件加载成功"
        
        # 构建完整远程路径
        FULL_REMOTE_PATH="$TARGET_BASE_DIR/$REMOTE_DIR_NAME"
        log_debug "远程路径: $FULL_REMOTE_PATH"
        
        return 0
    else
        log_warning "未找到备份配置文件，将使用默认配置"
        BACKUP_DIR="/backups"
        return 1
    fi
}

# ====================================================================
# 用户界面
# ====================================================================

show_title() {
    clear
    echo -e "${BLUE}================================================================${NC}"
    echo -e "${BLUE}         SnapSync v${SCRIPT_VERSION} 增强版系统恢复工具               ${NC}"
    echo -e "${BLUE}================================================================${NC}"
    echo -e "${CYAN}特性: ACL恢复 | 扩展属性 | 多格式支持 | 完整性验证 | 增量恢复${NC}"
    echo ""
}

show_restore_types() {
    echo -e "${CYAN}请选择恢复方式:${NC}"
    echo -e "1) ${GREEN}本地恢复${NC} - 从本地备份目录恢复"
    echo -e "2) ${GREEN}远程恢复${NC} - 从远程服务器下载并恢复"
    echo -e "3) ${GREEN}指定文件恢复${NC} - 指定快照文件路径恢复"
    echo ""
    
    while true; do
        read -p "请选择 [1-3]: " RESTORE_TYPE
        if [[ "$RESTORE_TYPE" =~ ^[1-3]$ ]]; then
            break
        fi
        echo -e "${RED}错误: 请输入 1-3 之间的数字${NC}"
    done
}

show_restore_modes() {
    echo -e "\n${YELLOW}恢复模式选择:${NC}"
    echo -e "1) ${GREEN}标准恢复${NC} - 保留网络配置、SSH密钥、主机名等关键配置"
    echo -e "2) ${GREEN}完全恢复${NC} - 恢复所有文件（可能导致网络配置丢失）"
    echo -e "3) ${GREEN}选择性恢复${NC} - 仅恢复指定目录"
    echo ""
    
    while true; do
        read -p "选择恢复模式 [1-3]: " RESTORE_MODE
        if [[ "$RESTORE_MODE" =~ ^[1-3]$ ]]; then
            break
        fi
        echo -e "${RED}错误: 请输入 1-3 之间的数字${NC}"
    done
}

# ====================================================================
# 快照文件检测和分析
# ====================================================================

detect_snapshot_format() {
    local file="\$1"
    local format=""
    
    # 检测文件格式
    if [[ "$file" =~ \.tar\.gz$ ]] || [[ "$file" =~ \.tgz$ ]]; then
        format="gzip"
    elif [[ "$file" =~ \.tar\.bz2$ ]]; then
        format="bzip2"
    elif [[ "$file" =~ \.tar\.xz$ ]]; then
        format="xz"
    elif [[ "$file" =~ \.tar$ ]]; then
        format="uncompressed"
    else
        # 通过文件头检测
        local file_type=$(file -b "$file" 2>/dev/null)
        if [[ "$file_type" =~ gzip ]]; then
            format="gzip"
        elif [[ "$file_type" =~ bzip2 ]]; then
            format="bzip2"
        elif [[ "$file_type" =~ XZ ]]; then
            format="xz"
        elif [[ "$file_type" =~ "POSIX tar" ]]; then
            format="uncompressed"
        else
            format="unknown"
        fi
    fi
    
    echo "$format"
}

get_decompression_cmd() {
    local format="\$1"
    
    case "$format" in
        "gzip")
            if command -v pigz >/dev/null 2>&1; then
                echo "pigz -dc"
            else
                echo "gunzip -c"
            fi
            ;;
        "bzip2")
            echo "bunzip2 -c"
            ;;
        "xz")
            echo "xz -dc"
            ;;
        "uncompressed")
            echo "cat"
            ;;
        *)
            echo ""
            ;;
    esac
}

verify_snapshot_integrity() {
    local snapshot_file="\$1"
    local checksum_file="${snapshot_file}.sha256"
    
    if [[ "$ENABLE_VERIFICATION" != "Y" ]]; then
        log_debug "跳过完整性验证（未启用）"
        return 0
    fi
    
    if [ ! -f "$checksum_file" ]; then
        log_warning "未找到校验和文件，跳过完整性验证"
        return 0
    fi
    
    log_info "验证快照完整性..."
    if sha256sum -c "$checksum_file" >/dev/null 2>&1; then
        log_success "快照完整性验证通过"
        return 0
    else
        log_error "快照完整性验证失败"
        return 1
    fi
}

analyze_snapshot() {
    local snapshot_file="\$1"
    
    log_info "分析快照文件: $(basename "$snapshot_file")"
    
    # 检测格式
    local format=$(detect_snapshot_format "$snapshot_file")
    log_debug "检测到格式: $format"
    
    if [ "$format" = "unknown" ]; then
        log_error "无法识别快照文件格式"
        return 1
    fi
    
    # 获取解压命令
    local decomp_cmd=$(get_decompression_cmd "$format")
    if [ -z "$decomp_cmd" ]; then
        log_error "不支持的压缩格式: $format"
        return 1
    fi
    
    # 验证完整性
    if ! verify_snapshot_integrity "$snapshot_file"; then
        read -p "完整性验证失败，是否继续？[y/N]: " continue_anyway
        if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
            return 1
        fi
    fi
    
    # 分析快照内容
    log_info "分析快照内容..."
    local content_info=$(eval "$decomp_cmd '$snapshot_file' | tar -tv 2>/dev/null | head -20")
    log_debug "快照内容预览:\n$content_info"
    
    # 检查是否包含增强特性
    local has_acl="否"
    local has_xattr="否"
    
    if eval "$decomp_cmd '$snapshot_file' | tar -tv 2>/dev/null | grep -q 'SCHILY.acl'"; then
        has_acl="是"
    fi
    
    if eval "$decomp_cmd '$snapshot_file' | tar -tv 2>/dev/null | grep -q 'SCHILY.xattr'"; then
        has_xattr="是"
    fi
    
    # 显示快照信息
    local file_size=$(stat -c%s "$snapshot_file" 2>/dev/null || echo 0)
    local file_date=$(date -r "$snapshot_file" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "未知")
    
    echo -e "\n${CYAN}快照分析结果:${NC}"
    echo -e "  文件名: $(basename "$snapshot_file")"
    echo -e "  大小: $(format_bytes $file_size)"
    echo -e "  日期: $file_date"
    echo -e "  格式: $format"
    echo -e "  ACL支持: $has_acl"
    echo -e "  扩展属性: $has_xattr"
    
    # 保存分析结果
    SNAPSHOT_FORMAT="$format"
    SNAPSHOT_DECOMP_CMD="$decomp_cmd"
    SNAPSHOT_HAS_ACL="$has_acl"
    SNAPSHOT_HAS_XATTR="$has_xattr"
    
    return 0
}

# ====================================================================
# 本地恢复功能
# ====================================================================

local_restore() {
    echo -e "\n${BLUE}=== 本地恢复模式 ===${NC}"
    
    if [ ! -d "$BACKUP_DIR" ]; then
        log_error "备份目录不存在: $BACKUP_DIR"
        return 1
    fi

    # 查找所有支持的快照文件
    log_info "搜索本地快照文件..."
    local snapshot_patterns=("*.tar.gz" "*.tgz" "*.tar.bz2" "*.tar.xz" "*.tar")
    SNAPSHOT_FILES=()
    
    for pattern in "${snapshot_patterns[@]}"; do
        while IFS= read -r -d '' file; do
            SNAPSHOT_FILES+=("$file")
        done < <(find "$BACKUP_DIR" -maxdepth 1 -name "system_snapshot_*.$pattern" -print0 2>/dev/null)
    done
    
    # 按时间排序
    if [ ${#SNAPSHOT_FILES[@]} -gt 0 ]; then
        IFS=$'\n' SNAPSHOT_FILES=($(printf '%s\n' "${SNAPSHOT_FILES[@]}" | sort -r))
    fi
    
    if [ ${#SNAPSHOT_FILES[@]} -eq 0 ]; then
        log_error "未找到快照文件"
        echo -e "${YELLOW}支持的格式: .tar.gz, .tgz, .tar.bz2, .tar.xz, .tar${NC}"
        return 1
    fi

    # 显示可用快照
    echo -e "\n${YELLOW}发现 ${#SNAPSHOT_FILES[@]} 个本地快照:${NC}"
    for i in "${!SNAPSHOT_FILES[@]}"; do
        local snapshot_name=$(basename "${SNAPSHOT_FILES[$i]}")
        local snapshot_size=$(stat -c%s "${SNAPSHOT_FILES[$i]}" 2>/dev/null || echo 0)
        local snapshot_date=$(date -r "${SNAPSHOT_FILES[$i]}" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "未知")
        local format=$(detect_snapshot_format "${SNAPSHOT_FILES[$i]}")
        
        echo -e "$((i+1))) ${GREEN}$snapshot_name${NC}"
        echo -e "    大小: $(format_bytes $snapshot_size) | 日期: $snapshot_date | 格式: $format"
    done

    echo ""
    while true; do
        read -p "选择快照编号 [1-${#SNAPSHOT_FILES[@]}]: " CHOICE
        if [[ "$CHOICE" =~ ^[0-9]+$ ]] && [ "$CHOICE" -ge 1 ] && [ "$CHOICE" -le ${#SNAPSHOT_FILES[@]} ]; then
            break
        fi
        echo -e "${RED}错误: 请输入 1-${#SNAPSHOT_FILES[@]} 之间的数字${NC}"
    done

    SELECTED_SNAPSHOT="${SNAPSHOT_FILES[$((CHOICE-1))]}"
    log_success "选择的快照: $(basename "$SELECTED_SNAPSHOT")"
    
    # 分析快照
    if ! analyze_snapshot "$SELECTED_SNAPSHOT"; then
        log_error "快照分析失败"
        return 1
    fi
    
    return 0
}

# ====================================================================
# 远程恢复功能
# ====================================================================

setup_ssh_connection() {
    log_info "设置SSH连接..."
    
    # SSH工具检查
    local ssh_tools="ssh scp"
    for tool in $ssh_tools; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            log_error "缺少SSH工具: $tool"
            return 1
        fi
    done

    # 使用配置文件中的连接信息
    if [ -z "$TARGET_IP" ]; then
        log_error "配置文件中缺少远程服务器信息"
        return 1
    fi

    log_info "远程服务器: $TARGET_USER@$TARGET_IP:$SSH_PORT"
    log_info "远程路径: $FULL_REMOTE_PATH"

    # SSH连接方式设置
    SSH_KEY="/root/.ssh/id_ed25519"
    SSH_OPTS='-o IdentitiesOnly=yes -o PreferredAuthentications=publickey -o PubkeyAuthentication=yes -o StrictHostKeyChecking=accept-new -o UserKnownHostsFile=/root/.ssh/known_hosts'
    
    if [ -f "$SSH_KEY" ]; then
        SSH_CMD="ssh -i $SSH_KEY -p $SSH_PORT $SSH_OPTS $TARGET_USER@$TARGET_IP"
        SCP_CMD="scp -i $SSH_KEY -P $SSH_PORT $SSH_OPTS"
        log_info "使用SSH密钥认证"
    else
        log_warning "未找到SSH密钥，使用密码认证"
        if ! command -v sshpass >/dev/null 2>&1; then
            log_info "安装sshpass..."
            apt-get update >/dev/null 2>&1 && apt-get install -y sshpass >/dev/null 2>&1
        fi
        
        read -s -p "SSH密码: " SSH_PASS
        echo ""
        
        if [ -z "$SSH_PASS" ]; then
            log_error "密码不能为空"
            return 1
        fi
        
        SSH_CMD="sshpass -p '$SSH_PASS' ssh -p $SSH_PORT $TARGET_USER@$TARGET_IP"
        SCP_CMD="sshpass -p '$SSH_PASS' scp -P $SSH_PORT"
    fi

    # 测试连接
    log_info "测试SSH连接..."
    if eval "$SSH_CMD 'echo \"SSH连接测试成功\"'" >/dev/null 2>&1; then
        log_success "SSH连接测试成功"
        return 0
    else
        log_error "SSH连接失败"
        echo -e "${YELLOW}请检查:${NC}"
        echo -e "  - SSH密钥或密码是否正确"
        echo -e "  - SSH端口是否正确 (当前: $SSH_PORT)"
        echo -e "  - 远程服务器是否可达"
        echo -e "  - 防火墙设置"
        return 1
    fi
}

get_remote_snapshots() {
    log_info "获取远程快照列表..."
    
    # 检查远程目录
    if ! eval "$SSH_CMD 'test -d \"$FULL_REMOTE_PATH/system_snapshots\"'" 2>/dev/null; then
        log_error "远程快照目录不存在: $FULL_REMOTE_PATH/system_snapshots"
        return 1
    fi
    
    # 获取快照列表，支持多种格式
    local remote_patterns="'*.tar.gz' '*.tgz' '*.tar.bz2' '*.tar.xz' '*.tar'"
    local snapshot_list=""
    
    for pattern in $remote_patterns; do
        local files=$(eval "$SSH_CMD 'find \"$FULL_REMOTE_PATH/system_snapshots\" -maxdepth 1 -name $pattern -type f 2>/dev/null'")
        if [ -n "$files" ]; then
            snapshot_list="$snapshot_list$files"$'\n'
        fi
    done
    
    if [ -z "$snapshot_list" ]; then
        log_error "远程未找到快照文件"
        return 1
    fi

    # 排序并去除空行
    snapshot_list=$(echo "$snapshot_list" | grep -v '^$' | sort -r)
    IFS=$'\n' REMOTE_SNAPSHOT_FILES=($snapshot_list)
    
    log_success "发现 ${#REMOTE_SNAPSHOT_FILES[@]} 个远程快照"
    return 0
}

show_remote_snapshots() {
    echo -e "\n${YELLOW}远程可用快照:${NC}"
    
    for i in "${!REMOTE_SNAPSHOT_FILES[@]}"; do
        local snapshot_name=$(basename "${REMOTE_SNAPSHOT_FILES[$i]}")
        local snapshot_info=""
        
        # 获取文件信息
        snapshot_info=$(eval "$SSH_CMD 'ls -lh \"${REMOTE_SNAPSHOT_FILES[$i]}\" 2>/dev/null'")
        
        if [ -n "$snapshot_info" ]; then
            local snapshot_size=$(echo "$snapshot_info" | awk '{print \$5}')
            local snapshot_date=$(echo "$snapshot_info" | awk '{print $6" "$7" "\$8}')
            local format=$(detect_snapshot_format "$snapshot_name")
            
            echo -e "$((i+1))) ${GREEN}$snapshot_name${NC}"
            echo -e "    大小: $snapshot_size | 日期: $snapshot_date | 格式: $format"
        else
            echo -e "$((i+1))) ${GREEN}$snapshot_name${NC} (无法获取详细信息)"
        fi
    done
}

download_remote_snapshot() {
    local selected_snapshot="\$1"
    local snapshot_name=$(basename "$selected_snapshot")
    
    # 创建临时目录
    mkdir -p "$TEMP_DIR"
    local local_snapshot="$TEMP_DIR/$snapshot_name"
    
    # 获取远程文件大小
    local remote_size=$(eval "$SSH_CMD 'stat -c%s \"$selected_snapshot\" 2>/dev/null'")
    if [ -n "$remote_size" ]; then
        log_info "远程文件大小: $(format_bytes $remote_size)"
        
        # 检查本地空间
        local available_space=$(df "$TEMP_DIR" | awk 'NR==2 {print \$4*1024}')
        if [ "$available_space" -lt "$remote_size" ]; then
            log_error "本地空间不足"
            echo -e "需要: $(format_bytes $remote_size)"
            echo -e "可用: $(format_bytes $available_space)"
            return 1
        fi
    fi

    log_info "正在下载快照文件..."
    log_debug "下载命令: $SCP_CMD $TARGET_USER@$TARGET_IP:\"$selected_snapshot\" \"$local_snapshot\""
    
    # 下载文件（支持进度显示）
    local start_time=$(date +%s)
    
    if command -v rsync >/dev/null 2>&1 && eval "$SSH_CMD 'command -v rsync >/dev/null 2>&1'"; then
        log_info "使用rsync下载（支持断点续传）..."
        if rsync -avz --partial --progress --timeout=1800 \
           -e "ssh -i $SSH_KEY -p $SSH_PORT $SSH_OPTS" \
           "$TARGET_USER@$TARGET_IP:$selected_snapshot" "$local_snapshot"; then
            download_success=1
        fi
    else
        # 使用scp下载
        if eval "$SCP_CMD $TARGET_USER@$TARGET_IP:\"$selected_snapshot\" \"$local_snapshot\""; then
            download_success=1
        fi
    fi
    
    if [ "$download_success" != 1 ]; then
        log_error "下载失败"
        return 1
    fi
    
    # 计算下载统计
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local downloaded_size=$(stat -c%s "$local_snapshot" 2>/dev/null || echo 0)
    
    log_success "下载完成"
    log_info "耗时: ${duration}秒, 大小: $(format_bytes $downloaded_size)"
    
    if [ "$duration" -gt 0 ] && [ "$downloaded_size" -gt 0 ]; then
        local speed=$(( downloaded_size / duration ))
        log_info "平均速度: $(format_bytes $speed)/s"
    fi
    
    # 下载校验和文件
    local checksum_file="${selected_snapshot}.sha256"
    local local_checksum="$TEMP_DIR/$(basename "$checksum_file")"
    
    if eval "$SSH_CMD 'test -f \"$checksum_file\"'" 2>/dev/null; then
        log_info "下载校验和文件..."
        eval "$SCP_CMD $TARGET_USER@$TARGET_IP:\"$checksum_file\" \"$local_checksum\"" >/dev/null 2>&1 || true
    fi
    
    SELECTED_SNAPSHOT="$local_snapshot"
    return 0
}

remote_restore() {
    echo -e "\n${BLUE}=== 远程恢复模式 ===${NC}"
    
    # 设置SSH连接
    if ! setup_ssh_connection; then
        return 1
    fi
    
    # 获取远程快照列表
    if ! get_remote_snapshots; then
        return 1
    fi
    
    # 显示远程快照
    show_remote_snapshots
    
    echo ""
    while true; do
        read -p "选择快照编号 [1-${#REMOTE_SNAPSHOT_FILES[@]}]: " CHOICE
        if [[ "$CHOICE" =~ ^[0-9]+$ ]] && [ "$CHOICE" -ge 1 ] && [ "$CHOICE" -le ${#REMOTE_SNAPSHOT_FILES[@]} ]; then
            break
        fi
        echo -e "${RED}错误: 请输入 1-${#REMOTE_SNAPSHOT_FILES[@]} 之间的数字${NC}"
    done

    local selected_remote="${REMOTE_SNAPSHOT_FILES[$((CHOICE-1))]}"
    log_success "选择的快照: $(basename "$selected_remote")"

    # 下载快照
    send_telegram "📥 开始下载快照\n文件: $(basename "$selected_remote")\n服务器: $TARGET_USER@$TARGET_IP\n时间: $(date '+%F %T')"
    
    if ! download_remote_snapshot "$selected_remote"; then
        send_telegram "❌ 快照下载失败\n文件: $(basename "$selected_remote")\n时间: $(date '+%F %T')"
        return 1
    fi
    
    send_telegram "✅ 快照下载成功\n文件: $(basename "$SELECTED_SNAPSHOT")\n时间: $(date '+%F %T')"
    
    # 分析下载的快照
    if ! analyze_snapshot "$SELECTED_SNAPSHOT"; then
        log_error "快照分析失败"
        return 1
    fi
    
    return 0
}

# ====================================================================
# 手动指定文件恢复
# ====================================================================

manual_file_restore() {
    echo -e "\n${BLUE}=== 指定文件恢复模式 ===${NC}"
    
    while true; do
        read -p "请输入快照文件的完整路径: " manual_file
        
        if [ -z "$manual_file" ]; then
            log_error "路径不能为空"
            continue
        fi
        
      if [ ! -f "$manual_file" ]; then
            log_error "文件不存在: $manual_file"
            continue
        fi
        
        # 检查文件是否可读
        if [ ! -r "$manual_file" ]; then
            log_error "文件不可读: $manual_file"
            continue
        fi
        
        break
    done
    
    SELECTED_SNAPSHOT="$manual_file"
    log_success "选择的快照文件: $SELECTED_SNAPSHOT"
    
    # 分析快照
    if ! analyze_snapshot "$SELECTED_SNAPSHOT"; then
        log_error "快照分析失败"
        return 1
    fi
    
    return 0
}

# ====================================================================
# 选择性恢复功能
# ====================================================================

selective_restore_menu() {
    echo -e "\n${CYAN}选择性恢复 - 请选择要恢复的目录:${NC}"
    echo -e "1) ${GREEN}/home${NC} - 用户目录"
    echo -e "2) ${GREEN}/etc${NC} - 配置文件"
    echo -e "3) ${GREEN}/var/www${NC} - Web文件"
    echo -e "4) ${GREEN}/var/lib${NC} - 应用数据"
    echo -e "5) ${GREEN}/opt${NC} - 第三方软件"
    echo -e "6) ${GREEN}自定义路径${NC}"
    echo -e "7) ${YELLOW}多选模式${NC}"
    echo ""
    
    SELECTIVE_PATHS=()
    
    while true; do
        read -p "选择要恢复的目录 [1-7]: " sel_choice
        
        case "$sel_choice" in
            1) SELECTIVE_PATHS+=("home/"); break ;;
            2) SELECTIVE_PATHS+=("etc/"); break ;;
            3) SELECTIVE_PATHS+=("var/www/"); break ;;
            4) SELECTIVE_PATHS+=("var/lib/"); break ;;
            5) SELECTIVE_PATHS+=("opt/"); break ;;
            6)
                read -p "请输入自定义路径 (相对于根目录，如 usr/local/): " custom_path
                if [ -n "$custom_path" ]; then
                    # 确保路径格式正确
                    custom_path=$(echo "$custom_path" | sed 's|^/||' | sed 's|/$|/|')
                    SELECTIVE_PATHS+=("$custom_path")
                fi
                break ;;
            7)
                echo -e "${CYAN}多选模式 - 输入数字选择目录，输入'done'结束:${NC}"
                while true; do
                    read -p "选择目录 [1-6] 或 'done': " multi_choice
                    case "$multi_choice" in
                        1) SELECTIVE_PATHS+=("home/"); echo "已添加: /home" ;;
                        2) SELECTIVE_PATHS+=("etc/"); echo "已添加: /etc" ;;
                        3) SELECTIVE_PATHS+=("var/www/"); echo "已添加: /var/www" ;;
                        4) SELECTIVE_PATHS+=("var/lib/"); echo "已添加: /var/lib" ;;
                        5) SELECTIVE_PATHS+=("opt/"); echo "已添加: /opt" ;;
                        6) 
                            read -p "自定义路径: " custom_path
                            if [ -n "$custom_path" ]; then
                                custom_path=$(echo "$custom_path" | sed 's|^/||' | sed 's|/$|/|')
                                SELECTIVE_PATHS+=("$custom_path")
                                echo "已添加: /$custom_path"
                            fi
                            ;;
                        "done") break ;;
                        *) echo -e "${RED}无效选择${NC}" ;;
                    esac
                done
                break ;;
            *) echo -e "${RED}错误: 请输入 1-7 之间的数字${NC}" ;;
        esac
    done
    
    if [ ${#SELECTIVE_PATHS[@]} -eq 0 ]; then
        log_error "未选择任何恢复路径"
        return 1
    fi
    
    echo -e "\n${GREEN}将恢复以下路径:${NC}"
    for path in "${SELECTIVE_PATHS[@]}"; do
        echo -e "  /${path%/}"
    done
    
    return 0
}

# ====================================================================
# 系统状态备份和恢复准备
# ====================================================================

backup_current_system() {
    log_info "备份当前系统关键配置..."
    
    mkdir -p "$BACKUP_CONFIG_DIR"
    
    # 网络配置
    [ -f /etc/fstab ] && cp /etc/fstab "$BACKUP_CONFIG_DIR/" 2>/dev/null
    [ -d /etc/network ] && cp -r /etc/network "$BACKUP_CONFIG_DIR/" 2>/dev/null
    [ -d /etc/netplan ] && cp -r /etc/netplan "$BACKUP_CONFIG_DIR/" 2>/dev/null
    [ -f /etc/hostname ] && cp /etc/hostname "$BACKUP_CONFIG_DIR/" 2>/dev/null
    [ -f /etc/hosts ] && cp /etc/hosts "$BACKUP_CONFIG_DIR/" 2>/dev/null
    [ -f /etc/resolv.conf ] && cp /etc/resolv.conf "$BACKUP_CONFIG_DIR/" 2>/dev/null
    
    # SSH配置
    [ -d /etc/ssh ] && cp -r /etc/ssh "$BACKUP_CONFIG_DIR/" 2>/dev/null
    [ -d /root/.ssh ] && cp -r /root/.ssh "$BACKUP_CONFIG_DIR/" 2>/dev/null
    
    # 系统服务状态
    systemctl list-units --type=service --state=active > "$BACKUP_CONFIG_DIR/active_services.list" 2>/dev/null
    
    # 当前用户和组
    cp /etc/passwd "$BACKUP_CONFIG_DIR/" 2>/dev/null
    cp /etc/group "$BACKUP_CONFIG_DIR/" 2>/dev/null
    cp /etc/shadow "$BACKUP_CONFIG_DIR/" 2>/dev/null
    
    # 挂载信息
    mount > "$BACKUP_CONFIG_DIR/current_mounts.list" 2>/dev/null
    
    log_success "系统配置备份完成"
}

stop_services() {
    log_info "停止相关系统服务..."
    
    # 需要停止的服务列表
    local services_to_stop="apache2 nginx mysql postgresql docker redis-server mongodb"
    
    for service in $services_to_stop; do
        if systemctl is-active --quiet "$service" 2>/dev/null; then
            log_info "停止服务: $service"
            systemctl stop "$service" 2>/dev/null || true
            sleep 2
        fi
    done
    
    # 同步文件系统
    log_info "同步文件系统..."
    sync
    
    log_success "服务停止完成"
}

# ====================================================================
# 核心恢复功能
# ====================================================================

build_tar_exclude_options() {
    local mode="\$1"
    local exclude_opts=""
    
    # 基础排除项（所有模式都排除）
    local base_excludes="dev/* proc/* sys/* run/* tmp/* var/tmp/* lost+found"
    local backup_excludes="$BACKUP_DIR/* /tmp/snapsync_* /tmp/current_config_backup_*"
    
    for item in $base_excludes $backup_excludes; do
        exclude_opts="$exclude_opts --exclude=$item"
    done
    
    # 标准模式排除项（保留网络配置等）
    if [ "$mode" = "standard" ]; then
        local preserve_configs="etc/fstab etc/hostname etc/hosts etc/network/* etc/netplan/*"
        preserve_configs="$preserve_configs etc/resolv.conf etc/ssh/* root/.ssh/*"
        
        for item in $preserve_configs; do
            exclude_opts="$exclude_opts --exclude=$item"
        done
    fi
    
    echo "$exclude_opts"
}

build_tar_include_options() {
    if [ ${#SELECTIVE_PATHS[@]} -gt 0 ]; then
        local include_opts=""
        for path in "${SELECTIVE_PATHS[@]}"; do
            include_opts="$include_opts $path*"
        done
        echo "$include_opts"
    fi
}

show_restore_progress() {
    local pid="\$1"
    local snapshot_file="\$2"
    
    # 获取快照文件大小
    local total_size=$(stat -c%s "$snapshot_file" 2>/dev/null || echo 0)
    
    echo -e "${CYAN}恢复进度监控:${NC}"
    
    while kill -0 "$pid" 2>/dev/null; do
        # 显示系统负载
        local load_avg=$(cat /proc/loadavg | awk '{print $1}')
        local mem_usage=$(free | awk 'NR==2{printf "%.1f%%", $3*100/\$2 }')
        
        printf "\r${YELLOW}负载: %s | 内存: %s | 状态: 恢复中...${NC}" "$load_avg" "$mem_usage"
        sleep 2
    done
    
    echo ""
}

perform_restore_operation() {
    local mode="\$1"
    local snapshot_file="$SELECTED_SNAPSHOT"
    
    log_info "开始执行恢复操作..."
    log_debug "恢复模式: $mode"
    log_debug "快照文件: $snapshot_file"
    log_debug "压缩格式: $SNAPSHOT_FORMAT"
    
    # 构建tar选项
    local exclude_opts=$(build_tar_exclude_options "$mode")
    local include_opts=$(build_tar_include_options)
    local tar_opts="--same-owner --same-permissions --numeric-owner"
    
    # 增强特性支持
    if [ "$SNAPSHOT_HAS_ACL" = "是" ] && command -v setfacl >/dev/null 2>&1; then
        tar_opts="$tar_opts --acls"
        log_info "启用ACL恢复"
    fi
    
    if [ "$SNAPSHOT_HAS_XATTR" = "是" ] && command -v setfattr >/dev/null 2>&1; then
        tar_opts="$tar_opts --xattrs"
        log_info "启用扩展属性恢复"
    fi
    
    # 构建完整命令
    local decomp_cmd="$SNAPSHOT_DECOMP_CMD"
    local tar_cmd="tar -x $tar_opts -f -"
    
    if [ -n "$include_opts" ]; then
        # 选择性恢复
        tar_cmd="$tar_cmd $include_opts"
        log_info "执行选择性恢复: ${SELECTIVE_PATHS[*]}"
    else
        # 全量恢复
        tar_cmd="$tar_cmd $exclude_opts"
    fi
    
    # 最终执行命令
    local full_cmd="$decomp_cmd '$snapshot_file' | $tar_cmd -C /"
    log_debug "执行命令: $full_cmd"
    
    # 记录开始时间
    local start_time=$(date +%s)
    
    # 执行恢复（后台运行以便显示进度）
    eval "$full_cmd" &
    local restore_pid=$!
    
    # 显示进度
    show_restore_progress $restore_pid "$snapshot_file"
    
    # 等待完成
    wait $restore_pid
    local exit_code=$?
    
    # 计算耗时
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    if [ $exit_code -eq 0 ]; then
        log_success "恢复操作完成 (耗时: ${duration}秒)"
        return 0
    else
        log_error "恢复操作失败 (退出码: $exit_code)"
        return 1
    fi
}

restore_preserved_configs() {
    local mode="\$1"
    
    if [ "$mode" != "standard" ] || [ ! -d "$BACKUP_CONFIG_DIR" ]; then
        return 0
    fi
    
    log_info "恢复保留的系统配置..."
    
    # 恢复网络配置
    [ -f "$BACKUP_CONFIG_DIR/fstab" ] && cp "$BACKUP_CONFIG_DIR/fstab" /etc/ 2>/dev/null
    [ -d "$BACKUP_CONFIG_DIR/network" ] && cp -r "$BACKUP_CONFIG_DIR/network" /etc/ 2>/dev/null
    [ -d "$BACKUP_CONFIG_DIR/netplan" ] && cp -r "$BACKUP_CONFIG_DIR/netplan" /etc/ 2>/dev/null
    [ -f "$BACKUP_CONFIG_DIR/hostname" ] && cp "$BACKUP_CONFIG_DIR/hostname" /etc/ 2>/dev/null
    [ -f "$BACKUP_CONFIG_DIR/hosts" ] && cp "$BACKUP_CONFIG_DIR/hosts" /etc/ 2>/dev/null
    [ -f "$BACKUP_CONFIG_DIR/resolv.conf" ] && cp "$BACKUP_CONFIG_DIR/resolv.conf" /etc/ 2>/dev/null
    
    # 恢复SSH配置
    if [ -d "$BACKUP_CONFIG_DIR/ssh" ]; then
        cp -r "$BACKUP_CONFIG_DIR/ssh" /etc/ 2>/dev/null
        chmod 644 /etc/ssh/*.pub 2>/dev/null
        chmod 600 /etc/ssh/*_key 2>/dev/null
    fi
    
    if [ -d "$BACKUP_CONFIG_DIR/.ssh" ]; then
        cp -r "$BACKUP_CONFIG_DIR/.ssh" /root/ 2>/dev/null
        chmod 700 /root/.ssh 2>/dev/null
        chmod 600 /root/.ssh/* 2>/dev/null
        chmod 644 /root/.ssh/*.pub 2>/dev/null
    fi
    
    log_success "保留配置恢复完成"
}

post_restore_tasks() {
    log_info "执行恢复后任务..."
    
    # 更新引导程序
    if command -v update-grub >/dev/null 2>&1; then
        log_info "更新GRUB配置..."
        update-grub >/dev/null 2>&1 || log_warning "GRUB更新失败"
    fi
    
    # 重新生成SSH主机密钥（如果需要）
    if [ ! -f /etc/ssh/ssh_host_ed25519_key ]; then
        log_info "重新生成SSH主机密钥..."
        ssh-keygen -A >/dev/null 2>&1 || log_warning "SSH密钥生成失败"
    fi
    
    # 更新系统信息
    if command -v update-motd >/dev/null 2>&1; then
        update-motd >/dev/null 2>&1 || true
    fi
    
    # 同步文件系统
    sync
    
    log_success "恢复后任务完成"
}

# 主恢复流程
# ====================================================================

execute_restore() {
    local restore_mode_name=""
    case "$RESTORE_MODE" in
        1) restore_mode_name="标准恢复" ;;
        2) restore_mode_name="完全恢复" ;;
        3) restore_mode_name="选择性恢复" ;;
    esac
    
    echo -e "\n${PURPLE}=== 开始执行恢复操作 ===${NC}"
    echo -e "${CYAN}恢复模式: $restore_mode_name${NC}"
    echo -e "${CYAN}快照文件: $(basename "$SELECTED_SNAPSHOT")${NC}"
    echo -e "${CYAN}时间戳: $(date '+%Y-%m-%d %H:%M:%S')${NC}"
    
    # 发送开始通知
    local notification_msg="🔧 系统恢复开始\n"
    notification_msg+="模式: $restore_mode_name\n"
    notification_msg+="快照: $(basename "$SELECTED_SNAPSHOT")\n"
    notification_msg+="格式: $SNAPSHOT_FORMAT\n"
    notification_msg+="时间: $(date '+%F %T')"
    send_telegram "$notification_msg"
    
    # 最后确认
    echo -e "\n${YELLOW}⚠️  警告: 恢复操作将覆盖现有系统文件!${NC}"
    read -p "确认执行恢复? [yes/NO]: " final_confirm
    
    if [ "$final_confirm" != "yes" ]; then
        log_warning "用户取消恢复操作"
        return 1
    fi
    
    # 选择性恢复的额外设置
    if [ "$RESTORE_MODE" -eq 3 ]; then
        if ! selective_restore_menu; then
            return 1
        fi
    fi
    
    # 备份当前系统配置
    backup_current_system
    
    # 停止相关服务
    stop_services
    
    # 执行具体恢复操作
    local mode_flag=""
    case "$RESTORE_MODE" in
        1) mode_flag="standard" ;;
        2) mode_flag="complete" ;;
        3) mode_flag="selective" ;;
    esac
    
    if ! perform_restore_operation "$mode_flag"; then
        log_error "恢复操作失败"
        send_telegram "❌ 系统恢复失败\n时间: $(date '+%F %T')\n请检查日志文件"
        return 1
    fi
    
    # 标准模式需要恢复保留的配置
    restore_preserved_configs "$mode_flag"
    
    # 执行恢复后任务
    post_restore_tasks
    
    log_success "系统恢复完成"
    
    # 发送成功通知
    local success_msg="✅ 系统恢复成功\n"
    success_msg+="模式: $restore_mode_name\n"
    success_msg+="快照: $(basename "$SELECTED_SNAPSHOT")\n"
    success_msg+="时间: $(date '+%F %T')\n"
    success_msg+="建议重启系统以确保所有更改生效"
    send_telegram "$success_msg"
    
    return 0
}

# ====================================================================
# 重启确认功能
# ====================================================================

show_reboot_options() {
    echo -e "\n${GREEN}恢复操作已成功完成!${NC}"
    echo -e "${YELLOW}建议重启系统以确保所有更改生效${NC}"
    echo ""
    echo -e "重启选项:"
    echo -e "1) ${GREEN}立即重启${NC}"
    echo -e "2) ${GREEN}延迟重启${NC} (指定分钟后)"
    echo -e "3) ${YELLOW}稍后手动重启${NC}"
    echo ""
    
    while true; do
        read -p "选择重启方式 [1-3]: " reboot_choice
        
        case "$reboot_choice" in
            1)
                echo -e "${CYAN}系统将在10秒后重启...${NC}"
                for i in {10..1}; do
                    echo -ne "\r${YELLOW}重启倒计时: ${i}秒 (Ctrl+C取消)${NC}"
                    sleep 1
                done
                echo ""
                log_info "执行立即重启"
                send_telegram "🔄 系统恢复完成，正在重启...\n时间: $(date '+%F %T')"
                reboot
                ;;
            2)
                while true; do
                    read -p "请输入延迟分钟数 [1-60]: " delay_minutes
                    if [[ "$delay_minutes" =~ ^[1-9][0-9]?$ ]] && [ "$delay_minutes" -le 60 ]; then
                        echo -e "${CYAN}系统将在 $delay_minutes 分钟后重启${NC}"
                        log_info "设置延迟重启: $delay_minutes 分钟"
                        send_telegram "⏰ 系统恢复完成，将在${delay_minutes}分钟后重启\n时间: $(date '+%F %T')"
                        shutdown -r +$delay_minutes "系统恢复完成，自动重启"
                        echo -e "${GREEN}延迟重启已设置${NC}"
                        break
                    else
                        echo -e "${RED}请输入 1-60 之间的数字${NC}"
                    fi
                done
                break
                ;;
            3)
                echo -e "${CYAN}请记得稍后手动重启系统${NC}"
                log_info "用户选择稍后手动重启"
                break
                ;;
            *)
                echo -e "${RED}请输入 1-3 之间的数字${NC}"
                ;;
        esac
        
        if [ "$reboot_choice" != "1" ]; then
            break
        fi
    done
}

# ====================================================================
# 错误处理和恢复
# ====================================================================

handle_restore_failure() {
    log_error "恢复过程中发生错误"
    
    echo -e "\n${RED}恢复失败处理选项:${NC}"
    echo -e "1) ${YELLOW}查看错误日志${NC}"
    echo -e "2) ${YELLOW}尝试使用其他快照${NC}"
    echo -e "3) ${YELLOW}恢复备份的配置${NC}"
    echo -e "4) ${RED}退出程序${NC}"
    
    while true; do
        read -p "选择处理方式 [1-4]: " error_choice
        
        case "$error_choice" in
            1)
                echo -e "\n${CYAN}=== 最近的错误日志 ===${NC}"
                if [ -f "$RESTORE_LOG_FILE" ]; then
                    tail -20 "$RESTORE_LOG_FILE"
                fi
                if [ -f "$DEBUG_LOG_FILE" ]; then
                    echo -e "\n${CYAN}=== 调试日志 ===${NC}"
                    tail -10 "$DEBUG_LOG_FILE"
                fi
                read -p "按回车继续..."
                ;;
            2)
                return 1  # 返回重新选择快照
                ;;
            3)
                if [ -d "$BACKUP_CONFIG_DIR" ]; then
                    log_info "恢复备份的配置文件..."
                    restore_preserved_configs "standard"
                    echo -e "${GREEN}配置文件已恢复${NC}"
                else
                    echo -e "${YELLOW}未找到备份的配置文件${NC}"
                fi
                read -p "按回车继续..."
                ;;
            4)
                log_info "用户选择退出程序"
                return 0
                ;;
            *)
                echo -e "${RED}请输入 1-4 之间的数字${NC}"
                ;;
        esac
    done
}

# ====================================================================
# 系统信息检查
# ====================================================================

check_system_status() {
    echo -e "\n${CYAN}=== 系统状态检查 ===${NC}"
    
    # 磁盘空间检查
    local root_usage=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
    if [ "$root_usage" -gt 90 ]; then
        log_warning "根分区使用率过高: ${root_usage}%"
    else
        log_info "根分区使用率: ${root_usage}%"
    fi
    
    # 内存检查
    local mem_info=$(free -m | awk 'NR==2{printf "使用: %sMB/%sMB (%.2f%%)", $3,$2,$3*100/\$2}')
    log_info "内存状态: $mem_info"
    
    # 负载检查
    local load_avg=$(uptime | awk -F'load average:' '{print $2}')
    log_info "系统负载: $load_avg"
    
    # CPU核心数
    local cpu_cores=$(nproc)
    log_info "CPU核心数: $cpu_cores"
    
    # 检查是否有足够空间进行恢复
    local available_space=$(df /tmp | awk 'NR==2 {print $4*1024}')  # 转换为字节
    log_info "临时目录可用空间: $(format_bytes $available_space)"
    
    return 0
}

# ====================================================================
# 帮助信息
# ====================================================================

show_help() {
    cat << 'EOF'
SnapSync v2.5 增强版系统恢复工具

用法: ./remote_restore [选项]

选项:
  -h, --help     显示帮助信息
  -v, --version  显示版本信息
  --check        仅检查系统状态
  --config       显示当前配置

恢复模式:
  标准恢复    - 保留网络配置、SSH密钥等关键配置
  完全恢复    - 恢复所有文件（可能导致网络配置丢失）
  选择性恢复  - 仅恢复指定目录

支持特性:
  - 多种压缩格式 (.tar.gz, .tar.bz2, .tar.xz, .tar)
  - ACL权限恢复
  - 扩展属性恢复
  - 完整性验证
  - 进度显示
  - Telegram通知
  - 智能配置保留

日志文件:
  /var/log/system_snapshot/restore.log       - 恢复日志
  /var/log/system_snapshot/restore_debug.log - 调试日志

示例:
  ./remote_restore              # 交互式恢复
  ./remote_restore --check      # 检查系统状态
  ./remote_restore --config     # 查看配置

注意事项:
  - 恢复操作会覆盖系统文件，请谨慎操作
  - 建议在测试环境先验证恢复流程
  - 标准模式推荐用于生产环境
  - 恢复后建议重启系统

EOF
}

show_version() {
    echo "SnapSync 恢复工具 v$SCRIPT_VERSION"
    echo "兼容备份版本: v2.5+"
    echo "作者: SnapSync Development Team"
    echo "许可证: MIT"
}

show_current_config() {
    if [ -f "$CONFIG_FILE" ]; then
        echo -e "${CYAN}=== 当前配置信息 ===${NC}"
        echo "配置文件: $CONFIG_FILE"
        echo ""
        
        # 安全显示配置（隐藏敏感信息）
        while IFS='=' read -r key value; do
            # 跳过注释和空行
            [[ "$key" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$key" ]] && continue
            
            # 隐藏敏感信息
            if [[ "$key" =~ (PASSWORD|TOKEN|PASS) ]]; then
                echo "$key=****"
            else
                echo "$key=$value"
            fi
        done < "$CONFIG_FILE"
    else
        echo -e "${YELLOW}配置文件不存在: $CONFIG_FILE${NC}"
    fi
}

# ====================================================================
# 命令行参数处理
# ====================================================================

parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case \$1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            --check)
                check_system_status
                exit 0
                ;;
            --config)
                show_current_config
                exit 0
                ;;
            *)
                echo -e "${RED}未知参数: $1${NC}"
                echo "使用 --help 查看帮助信息"
                exit 1
                ;;
        esac
        shift
    done
}

# ====================================================================
# 主程序流程
# ====================================================================

main() {
    # 处理命令行参数
    parse_arguments "$@"
    
    # 显示标题
    show_title
    
    # 检查系统要求
    if ! check_requirements; then
        log_error "系统要求检查失败"
        exit 1
    fi
    
    # 检查系统状态
    check_system_status
    
    # 加载配置
    load_config
    
    # 主循环 - 允许重试
    while true; do
        # 选择恢复方式
        show_restore_types
        
        # 根据选择执行相应的恢复准备
        case "$RESTORE_TYPE" in
            1)
                if ! local_restore; then
                    if ! handle_restore_failure; then
                        continue  # 重新选择
                    else
                        break  # 退出
                    fi
                fi
                ;;
            2)
                if ! remote_restore; then
                    if ! handle_restore_failure; then
                        continue  # 重新选择
                    else
                        break  # 退出
                    fi
                fi
                ;;
            3)
                if ! manual_file_restore; then
                    if ! handle_restore_failure; then
                        continue  # 重新选择
                    else
                        break  # 退出
                    fi
                fi
                ;;
        esac
        
        # 选择恢复模式
        show_restore_modes
        
        # 执行恢复
        if execute_restore; then
            # 显示重启选项
            show_reboot_options
            break
        else
            # 处理恢复失败
            if ! handle_restore_failure; then
                continue  # 重新开始
            else
                break  # 退出
                   fi
    done
    
    # 清理临时文件
    cleanup_temp_files
    
    log_info "恢复程序结束"
}

# ====================================================================
# 临时文件清理
# ====================================================================

cleanup_temp_files() {
    log_info "清理临时文件..."
    
    # 清理下载的快照文件
    if [ -n "$SELECTED_SNAPSHOT" ] && [[ "$SELECTED_SNAPSHOT" == "$TEMP_DIR"* ]]; then
        if [ -f "$SELECTED_SNAPSHOT" ]; then
            log_debug "删除临时快照: $SELECTED_SNAPSHOT"
            rm -f "$SELECTED_SNAPSHOT"
        fi
        
        # 清理相关校验文件
        rm -f "${SELECTED_SNAPSHOT}.sha256" 2>/dev/null
    fi
    
    # 清理临时目录（保留备份配置）
    if [ -d "$TEMP_DIR" ]; then
        find "$TEMP_DIR" -type f -name "system_snapshot_*" -delete 2>/dev/null
        find "$TEMP_DIR" -type f -name "*.sha256" -delete 2>/dev/null
    fi
    
    log_debug "临时文件清理完成"
}

# ====================================================================
# 信号处理
# ====================================================================

handle_interrupt() {
    echo -e "\n\n${YELLOW}收到中断信号，正在安全退出...${NC}"
    
    log_warning "程序被用户中断"
    
    # 清理临时文件
    cleanup_temp_files
    
    # 如果有后台进程，尝试终止
    if [ -n "$restore_pid" ]; then
        log_info "终止恢复进程..."
        kill -TERM "$restore_pid" 2>/dev/null || true
        sleep 2
        kill -KILL "$restore_pid" 2>/dev/null || true
    fi
    
    # 发送中断通知
    send_telegram "⚠️ 系统恢复被用户中断\n时间: $(date '+%F %T')"
    
    echo -e "${RED}程序已中断退出${NC}"
    exit 130
}

# 设置信号处理
trap handle_interrupt INT TERM

# ====================================================================
# 脚本验证和完整性检查
# ====================================================================

verify_script_integrity() {
    # 检查脚本文件完整性
    if [ ! -r "$0" ]; then
        log_error "无法读取脚本文件"
        return 1
    fi
    
    # 检查关键函数是否定义
    local critical_functions="load_config show_restore_types execute_restore"
    for func in $critical_functions; do
        if ! type "$func" >/dev/null 2>&1; then
            log_error "关键函数未定义: $func"
            return 1
        fi
    done
    
    return 0
}

# ====================================================================
# 启动检查和初始化
# ====================================================================

initialize_script() {
    # 验证脚本完整性
    if ! verify_script_integrity; then
        echo -e "${RED}脚本完整性检查失败${NC}"
        exit 1
    fi
    
    # 创建必要的目录
    mkdir -p "$TEMP_DIR"
    mkdir -p "$(dirname "$RESTORE_LOG_FILE")"
    mkdir -p "$(dirname "$DEBUG_LOG_FILE")"
    
    # 初始化日志
    log_info "====== SnapSync 恢复工具启动 v$SCRIPT_VERSION ======"
    log_info "启动时间: $(date '+%Y-%m-%d %H:%M:%S')"
    log_info "用户: $(whoami)"
    log_info "PID: $$"
    
    # 记录系统信息
    log_debug "系统信息: $(uname -a)"
    log_debug "脚本路径: $0"
    log_debug "工作目录: $(pwd)"
    
    return 0
}

# ====================================================================
# 错误退出处理
# ====================================================================

exit_with_error() {
    local error_msg="$1"
    local exit_code="${2:-1}"
    
    log_error "$error_msg"
    send_telegram "❌ 恢复工具错误\n错误: $error_msg\n时间: $(date '+%F %T')"
    
    cleanup_temp_files
    exit "$exit_code"
}

# ====================================================================
# 运行时安全检查
# ====================================================================

runtime_safety_check() {
    # 检查是否在容器中运行
    if [ -f /.dockerenv ]; then
        log_warning "检测到在Docker容器中运行"
        echo -e "${YELLOW}警告: 在容器中恢复系统可能导致不可预期的结果${NC}"
        read -p "是否继续? [y/N]: " container_confirm
        if [ "$container_confirm" != "y" ] && [ "$container_confirm" != "Y" ]; then
            exit_with_error "用户取消容器中的恢复操作" 0
        fi
    fi
    
    # 检查文件系统类型
    local rootfs_type=$(df -T / | awk 'NR==2 {print $2}')
    if [ "$rootfs_type" = "tmpfs" ] || [ "$rootfs_type" = "ramfs" ]; then
        log_warning "根文件系统类型: $rootfs_type"
        echo -e "${YELLOW}警告: 当前根文件系统为内存文件系统，恢复后数据将在重启后丢失${NC}"
        read -p "是否继续? [y/N]: " tmpfs_confirm
        if [ "$tmpfs_confirm" != "y" ] && [ "$tmpfs_confirm" != "Y" ]; then
            exit_with_error "用户取消内存文件系统的恢复操作" 0
        fi
    fi
    
    # 检查是否有足够权限
    if [ ! -w /etc ] || [ ! -w /var ] || [ ! -w /usr ]; then
        exit_with_error "权限不足，无法写入系统目录"
    fi
    
    return 0
}

# ====================================================================
# 预恢复系统检查
# ====================================================================

pre_restore_system_check() {
    echo -e "\n${CYAN}=== 恢复前系统检查 ===${NC}"
    
    local warnings=0
    local errors=0
    
    # 磁盘空间检查
    local root_avail=$(df / | awk 'NR==2 {print $4*1024}')  # 转换为字节
    if [ "$root_avail" -lt 1073741824 ]; then  # 1GB
        log_warning "根分区可用空间不足1GB: $(format_bytes $root_avail)"
        warnings=$((warnings + 1))
    fi
    
    # 检查重要服务状态
    local critical_services="systemd sshd"
    for service in $critical_services; do
        if ! systemctl is-active --quiet "$service" 2>/dev/null; then
            log_warning "关键服务未运行: $service"
            warnings=$((warnings + 1))
        fi
    done
    
    # 检查网络连接（用于Telegram通知）
    if [ -n "$TELEGRAM_BOT_TOKEN" ] && [ -n "$TELEGRAM_CHAT_ID" ]; then
        if ! curl -s --connect-timeout 5 "https://api.telegram.org" >/dev/null; then
            log_warning "无法连接到Telegram API，通知功能可能不可用"
            warnings=$((warnings + 1))
        fi
    fi
    
    # 检查系统负载
    local load1=$(cat /proc/loadavg | awk '{print $1}')
    local cpu_cores=$(nproc)
    if (( $(echo "$load1 > $cpu_cores * 2" | bc -l) )); then
        log_warning "系统负载过高: $load1 (CPU核心数: $cpu_cores)"
        warnings=$((warnings + 1))
    fi
    
    # 显示检查结果
    if [ "$errors" -gt 0 ]; then
        echo -e "${RED}发现 $errors 个错误，建议修复后再继续${NC}"
        return 1
    elif [ "$warnings" -gt 0 ]; then
        echo -e "${YELLOW}发现 $warnings 个警告${NC}"
        read -p "是否忽略警告继续恢复? [y/N]: " ignore_warnings
        if [ "$ignore_warnings" != "y" ] && [ "$ignore_warnings" != "Y" ]; then
            return 1
        fi
    else
        log_success "系统检查通过"
    fi
    
    return 0
}

# ====================================================================
# 配置文件模板生成
# ====================================================================

generate_config_template() {
    if [ ! -f "$CONFIG_FILE" ]; then
        log_info "生成配置文件模板..."
        
        cat > "$CONFIG_FILE" << 'EOF'
# SnapSync 恢复工具配置文件
# 请根据实际情况修改以下配置

# 远程服务器连接信息
TARGET_IP=""              # 远程服务器IP地址
TARGET_USER="root"        # SSH用户名
SSH_PORT="22"            # SSH端口
REMOTE_BASE_PATH="/opt/system_backups"  # 远程备份基础路径

# 本地设置
BACKUP_DIR="/opt/system_backups"         # 本地备份目录

# Telegram通知设置 (可选)
TELEGRAM_BOT_TOKEN=""     # Telegram机器人Token
TELEGRAM_CHAT_ID=""       # Telegram聊天ID

# 高级选项
VERIFY_CHECKSUMS="true"   # 是否验证校验和
PRESERVE_ACL="true"       # 是否保留ACL权限
PRESERVE_XATTR="true"     # 是否保留扩展属性
DEBUG_MODE="false"        # 是否启用调试模式
EOF
        
        chmod 600 "$CONFIG_FILE"
        log_success "配置文件已生成: $CONFIG_FILE"
        echo -e "${YELLOW}请编辑配置文件后重新运行程序${NC}"
        exit 0
    fi
}

# ====================================================================
# 主程序入口点
# ====================================================================

# 检查是否以root权限运行
if [ "$EUID" -ne 0 ]; then
    echo -e "${RED}错误: 此脚本需要root权限运行${NC}"
    echo "请使用: sudo $0"
    exit 1
fi

# 脚本初始化
if ! initialize_script; then
    exit_with_error "脚本初始化失败"
fi

# 生成配置模板（如果不存在）
generate_config_template

# 运行时安全检查
if ! runtime_safety_check; then
    exit_with_error "运行时安全检查失败"
fi

# 恢复前系统检查
if ! pre_restore_system_check; then
    log_warning "系统检查未通过，退出程序"
    exit 1
fi

# 执行主程序
main "$@"

# 程序结束
log_info "====== SnapSync 恢复工具结束 ======"
exit 0

# ====================================================================
# 脚本结束标记
# ====================================================================
# SnapSync v2.5 Enhanced System Restore Tool
# 版权所有 (c) 2024 SnapSync Development Team
# 
# 此脚本提供以下功能:
# - 本地和远程快照恢复
# - 多种恢复模式（标准/完全/选择性）
# - 多压缩格式支持
# - ACL和扩展属性恢复
# - 完整性验证
# - Telegram通知
# - 智能配置保留
# - 详细的日志记录
# - 错误处理和恢复
# 
# 使用前请仔细阅读文档和配置说明
# ====================================================================
EOF



